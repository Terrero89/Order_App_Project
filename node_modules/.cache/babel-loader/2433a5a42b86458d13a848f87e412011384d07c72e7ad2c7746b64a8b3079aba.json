{"ast":null,"code":"import _slicedToArray from\"/home/terrero/Documents/Web Development/Frontend/React_Projects/food_order_app/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";import _toConsumableArray from\"/home/terrero/Documents/Web Development/Frontend/React_Projects/food_order_app/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";import _objectSpread from\"/home/terrero/Documents/Web Development/Frontend/React_Projects/food_order_app/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";import React,{useReducer}from'react';import CartContext from'./cart-context';//this component is used to wrap the component PROVIDER, so it\n//can be easily used to wrap any element that will receive any\n//data from this provider\nimport{jsx as _jsx}from\"react/jsx-runtime\";var defaultCartState={items:[],totalAmount:0};//state: last snapshot or update of data\n//actions: will dispatch actions that will be changing the state\n//cartReducer returns default state updated\nvar cartReducer=function cartReducer(state,action){//LOGIC TO MAKE SURE ONE ITEM IS ADDED TO THE ARRAY AND COUNT ALL PRICE AMOUNT\nif(action.type==='ADD'){var updatedTotalAmount=state.totalAmount+action.item.price*action.item.amount;//to determine price total price of specific item\nvar existingCartItemIndex=state.items.findIndex(function(item){return item.id===action.item.id;});//will find especific ide to find.\nvar existingCartItem=state.items[existingCartItemIndex];// will check if item exist and will not add it.\nvar updatedItems;if(existingCartItem){var updatedItem=_objectSpread(_objectSpread({},existingCartItem),{},{amount:existingCartItem.amount+action.item.amount});updatedItems=_toConsumableArray(state.items);updatedItems[existingCartItemIndex]=updatedItem;}else{updatedItems=state.items.concat(action.item);// adding the item to the array\n}if(action.type==='REMOVE'){var _existingCartItemIndex=state.items.findIndex(function(item){return item.id===action.id;});//will find especific ide to find.\nvar existingItem=state.items[_existingCartItemIndex];var _updatedTotalAmount=state.totalAmount-existingItem.price;var _updatedItems;if(existingItem.amount===1){_updatedItems=state.items.filter(function(item){return item.id!==action.id;});}else{var _updatedItem=_objectSpread(_objectSpread({},existingItem),{},{amount:existingItem.amount-1});//decrease the value by 1\n_updatedItems=_toConsumableArray(state.items);_updatedItems[_existingCartItemIndex]=_updatedItem;}return{items:_updatedItems,totalAmount:_updatedTotalAmount};}// return defaultCartState\nreturn{items:updatedItems,totalAmount:updatedTotalAmount};}//cleaning the cart after order\nif(action.type==='CLEAR'){return defaultCartState;}return defaultCartState;};var CartProvider=function CartProvider(props){//destructure to assign variables to a different constants\nvar _useReducer=useReducer(cartReducer,defaultCartState),_useReducer2=_slicedToArray(_useReducer,2),cartState=_useReducer2[0],dispatchCartAction=_useReducer2[1];//logic: if existing item -> update the amount\n//if not existing item -> then add new item and update amount\n//useState or usereducer can update state\nvar addItemCartHandler=function addItemCartHandler(item){dispatchCartAction({type:\"ADD\",item:item});};var removeItemCartHandler=function removeItemCartHandler(id){dispatchCartAction({type:\"REMOVE\",id:id});};var clearCartHandler=function clearCartHandler(){dispatchCartAction({type:'CLEAR'});};var cartContext={// items: [], we use cartState to provider current or latest snapshot\nitems:cartState.items,// totalAmount: 0,we use totalAmount state to provider current or latest snapshot\ntotalAmount:cartState.totalAmount,addItem:addItemCartHandler,removeItem:removeItemCartHandler,clearCart:clearCartHandler};//cartContext will be the value we are going to update or pass in the components\nreturn/*#__PURE__*/_jsx(CartContext.Provider,{value:cartContext,children:props.children});};export default CartProvider;","map":{"version":3,"names":["React","useReducer","CartContext","jsx","_jsx","defaultCartState","items","totalAmount","cartReducer","state","action","type","updatedTotalAmount","item","price","amount","existingCartItemIndex","findIndex","id","existingCartItem","updatedItems","updatedItem","_objectSpread","_toConsumableArray","concat","existingItem","filter","CartProvider","props","_useReducer","_useReducer2","_slicedToArray","cartState","dispatchCartAction","addItemCartHandler","removeItemCartHandler","clearCartHandler","cartContext","addItem","removeItem","clearCart","Provider","value","children"],"sources":["/home/terrero/Documents/Web Development/Frontend/React_Projects/food_order_app/src/store/CartProvider.js"],"sourcesContent":["import React, {useReducer} from 'react';\nimport CartContext from './cart-context';\n\n//this component is used to wrap the component PROVIDER, so it\n//can be easily used to wrap any element that will receive any\n//data from this provider\n\n\nconst defaultCartState = {\n    items: [],\n    totalAmount: 0,\n}\n//state: last snapshot or update of data\n//actions: will dispatch actions that will be changing the state\n//cartReducer returns default state updated\nconst cartReducer = (state, action) => {\n//LOGIC TO MAKE SURE ONE ITEM IS ADDED TO THE ARRAY AND COUNT ALL PRICE AMOUNT\n    if (action.type === 'ADD') {\n        const updatedTotalAmount = state.totalAmount + action.item.price * action.item.amount //to determine price total price of specific item\n        const existingCartItemIndex = state.items.findIndex(item => item.id === action.item.id) //will find especific ide to find.\n        const existingCartItem = state.items[existingCartItemIndex] // will check if item exist and will not add it.\n\n        let updatedItems;\n\n        if (existingCartItem) {\n            const updatedItem = {\n                ...existingCartItem,\n                amount: existingCartItem.amount + action.item.amount\n            };\n            updatedItems = [...state.items]\n            updatedItems[existingCartItemIndex] = updatedItem\n        } else {\n\n            updatedItems = state.items.concat(action.item) // adding the item to the array\n        }\n\n        if (action.type === 'REMOVE') {\n\n            const existingCartItemIndex = state.items.findIndex(item => item.id === action.id); //will find especific ide to find.\n            const existingItem = state.items[existingCartItemIndex]\n            const updatedTotalAmount = state.totalAmount - existingItem.price\n\n            let updatedItems;\n            if (existingItem.amount === 1) {\n                updatedItems = state.items.filter(item => item.id !== action.id)\n            } else {\n                const updatedItem = {...existingItem, amount: existingItem.amount - 1} //decrease the value by 1\n                updatedItems = [...state.items]\n                updatedItems[existingCartItemIndex] = updatedItem\n            }\n            return {\n                items: updatedItems,\n                totalAmount: updatedTotalAmount\n            }\n        }\n        // return defaultCartState\n        return {\n            items: updatedItems,\n            totalAmount: updatedTotalAmount\n        }\n    }\n\n    //cleaning the cart after order\n    if (action.type === 'CLEAR') {\n        return defaultCartState\n    \n}\n    return defaultCartState\n}\nconst CartProvider = (props) => {\n    //destructure to assign variables to a different constants\n    const [cartState, dispatchCartAction] = useReducer(cartReducer, defaultCartState)\n\n    //logic: if existing item -> update the amount\n    //if not existing item -> then add new item and update amount\n    //useState or usereducer can update state\n    const addItemCartHandler = item => {\n        dispatchCartAction({type: \"ADD\", item: item})\n    }\n    const removeItemCartHandler = id => {\n        dispatchCartAction({type: \"REMOVE\", id: id})\n    }\n\n    const clearCartHandler = () => {\n        dispatchCartAction({type: 'CLEAR'})\n    }\n\n    const cartContext = {\n        // items: [], we use cartState to provider current or latest snapshot\n        items: cartState.items,\n        // totalAmount: 0,we use totalAmount state to provider current or latest snapshot\n        totalAmount: cartState.totalAmount,\n        addItem: addItemCartHandler,\n        removeItem: removeItemCartHandler,\n        clearCart:clearCartHandler\n    }\n    //cartContext will be the value we are going to update or pass in the components\n    return <CartContext.Provider value={cartContext}>\n        {props.children}\n\n    </CartContext.Provider>\n}\n\nexport default CartProvider;"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}